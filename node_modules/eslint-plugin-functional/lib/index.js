'use strict';

var deepMerge = require('deepmerge');
require('array.prototype.flatmap/auto.js');
var escapeRegExp = require('escape-string-regexp');
var experimentalUtils = require('@typescript-eslint/experimental-utils');
require('object.fromentries/auto.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var deepMerge__default = /*#__PURE__*/_interopDefaultLegacy(deepMerge);
var escapeRegExp__default = /*#__PURE__*/_interopDefaultLegacy(escapeRegExp);

const config$a = {
    rules: {
        "functional/functional-parameters": "error",
        "functional/immutable-data": "error",
        "functional/no-class": "error",
        "functional/no-conditional-statement": "error",
        "functional/no-expression-statement": "error",
        "functional/no-let": "error",
        "functional/no-loop-statement": "error",
        "functional/no-promise-reject": "error",
        "functional/no-this-expression": "error",
        "functional/no-throw-statement": "error",
        "functional/no-try-statement": "error",
        "functional/prefer-tacit": ["warn", { assumeTypes: { allowFixer: false } }],
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-method-signature": "error",
                "functional/no-mixed-type": "error",
                "functional/prefer-readonly-type": "error",
                "functional/prefer-tacit": ["error", { assumeTypes: false }],
                "functional/prefer-type-literal": "error",
                "functional/no-return-void": "error",
            },
        },
    ],
};

const config$9 = {
    rules: {
        "functional/functional-parameters": "error",
    },
};

const config$8 = {
    rules: {
        "prefer-const": "error",
        "no-param-reassign": "error",
        "no-var": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "@typescript-eslint/explicit-function-return-type": [
                    "error",
                    {
                        allowExpressions: true,
                        allowTypedFunctionExpressions: true,
                        allowHigherOrderFunctions: true,
                    },
                ],
            },
        },
    ],
};

const config$7 = {
    rules: {
        "functional/no-let": "error",
        "functional/immutable-data": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-method-signature": "warn",
                "functional/prefer-readonly-type": "error",
            },
        },
    ],
};

const config$6 = {
    rules: {
        "functional/no-throw-statement": "error",
        "functional/no-try-statement": "error",
    },
};

const config$5 = {
    rules: {
        "functional/no-this-expression": "error",
        "functional/no-class": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-mixed-type": "error",
                "functional/prefer-type-literal": "error",
            },
        },
    ],
};

const config$4 = {
    rules: {
        "functional/no-expression-statement": "error",
        "functional/no-conditional-statement": "error",
        "functional/no-loop-statement": "error",
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/no-return-void": "error",
            },
        },
    ],
};

const config$3 = deepMerge.all([
    config$9,
    config$7,
    config$6,
    config$5,
    config$4,
]);

const config$2 = deepMerge__default['default'](config$3, {
    rules: {
        "functional/immutable-data": ["error", { ignoreClass: "fieldsOnly" }],
        "functional/no-conditional-statement": "off",
        "functional/no-expression-statement": "off",
        "functional/no-try-statement": "off",
        "functional/functional-parameters": [
            "error",
            {
                enforceParameterCount: false,
            },
        ],
    },
});

const config$1 = {
    rules: {
        "functional/prefer-tacit": ["warn", { assumeTypes: { allowFixer: false } }],
    },
    overrides: [
        {
            files: ["*.ts", "*.tsx"],
            rules: {
                "functional/prefer-tacit": ["error", { assumeTypes: false }],
            },
        },
    ],
};

var ts = (() => {
    try {
        return require("typescript");
    }
    catch (error) {
        return undefined;
    }
})();

function isArrayExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ArrayExpression;
}
function isAssignmentExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.AssignmentExpression;
}
function isAssignmentPattern(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.AssignmentPattern;
}
function isBlockStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.BlockStatement;
}
function isBreakStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.BreakStatement;
}
function isCallExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.CallExpression;
}
function isClassProperty(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ClassProperty;
}
function isClassLike(node) {
    return (node.type === experimentalUtils.AST_NODE_TYPES.ClassDeclaration ||
        node.type === experimentalUtils.AST_NODE_TYPES.ClassExpression);
}
function isContinueStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ContinueStatement;
}
function isExpressionStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ExpressionStatement;
}
function isFunctionDeclaration(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.FunctionDeclaration;
}
function isFunctionExpressionLike(node) {
    return (node.type === experimentalUtils.AST_NODE_TYPES.FunctionExpression ||
        node.type === experimentalUtils.AST_NODE_TYPES.ArrowFunctionExpression);
}
function isFunctionLike(node) {
    return isFunctionDeclaration(node) || isFunctionExpressionLike(node);
}
function isIdentifier(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.Identifier;
}
function isIfStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.IfStatement;
}
function isMemberExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.MemberExpression;
}
function isMethodDefinition(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.MethodDefinition;
}
function isNewExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.NewExpression;
}
function isProperty(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.Property;
}
function isRestElement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.RestElement;
}
function isReturnStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ReturnStatement;
}
function isSwitchStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.SwitchStatement;
}
function isThisExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ThisExpression;
}
function isThrowStatement(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.ThrowStatement;
}
function isTSArrayType(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSArrayType;
}
function isTSFunctionType(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSFunctionType;
}
function isTSIndexSignature(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSIndexSignature;
}
function isTSInterfaceBody(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSInterfaceBody;
}
function isTSInterfaceHeritage(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSInterfaceHeritage;
}
function isTSNullKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSNullKeyword;
}
function isTSParameterProperty(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSParameterProperty;
}
function isTSPropertySignature(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSPropertySignature;
}
function isTSTupleType(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTupleType;
}
function isTSTypeAnnotation(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeAnnotation;
}
function isTSTypeLiteral(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeLiteral;
}
function isTSTypeOperator(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeOperator;
}
function isTSTypeReference(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSTypeReference;
}
function isTSUndefinedKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSUndefinedKeyword;
}
function isTSVoidKeyword(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.TSVoidKeyword;
}
function isUnaryExpression(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.UnaryExpression;
}
function isVariableDeclaration(node) {
    return node.type === experimentalUtils.AST_NODE_TYPES.VariableDeclaration;
}
function hasID(node) {
    return Object.prototype.hasOwnProperty.call(node, "id");
}
function hasKey(node) {
    return Object.prototype.hasOwnProperty.call(node, "key");
}
function isUnionType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Union;
}
function isArrayType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null
        : type !== null &&
            ((type.symbol && type.symbol.name === "Array") ||
                (isUnionType(type) &&
                    type.types.some((t) => isArrayType(t, false, null))));
}
function isArrayConstructorType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null && isIdentifier(node) && node.name === "Array"
        : type !== null &&
            ((type.symbol && type.symbol.name === "ArrayConstructor") ||
                (isUnionType(type) &&
                    type.types.some((t) => isArrayConstructorType(t, false, null))));
}
function isObjectConstructorType(type, assumeType = false, node = null) {
    return assumeType === true && type === null
        ? node !== null && isIdentifier(node) && node.name === "Object"
        : type !== null &&
            ((type.symbol && type.symbol.name === "ObjectConstructor") ||
                (isUnionType(type) &&
                    type.types.some((t) => isObjectConstructorType(t, false, null))));
}
function isNeverType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Never;
}
function isVoidType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Void;
}
function isNullType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Null;
}
function isUndefinedType(type) {
    return ts !== undefined && type.flags === ts.TypeFlags.Undefined;
}

function getAncestorOfType(checker, node, child = null) {
    return checker(node, child)
        ? node
        : node.parent == undefined
            ? null
            : getAncestorOfType(checker, node.parent, node);
}
function inFunctionBody(node) {
    return (getAncestorOfType((n, c) => isFunctionLike(n) && n.body === c, node) !== null);
}
function inClass(node) {
    return getAncestorOfType(isClassLike, node) !== null;
}
function inReadonly(node) {
    var _a, _b, _c;
    if (node.parent &&
        isTSTypeLiteral(node.parent) &&
        node.parent.parent &&
        isTSTypeAnnotation(node.parent.parent)) {
        return false;
    }
    const expressionOrTypeName = (_b = (_a = getAncestorOfType(isTSTypeReference, node)) === null || _a === void 0 ? void 0 : _a.typeName) !== null && _b !== void 0 ? _b : (_c = getAncestorOfType(isTSInterfaceHeritage, node)) === null || _c === void 0 ? void 0 : _c.expression;
    return (experimentalUtils.ASTUtils.isIdentifier(expressionOrTypeName) &&
        expressionOrTypeName.name === "Readonly");
}
function inInterface(node) {
    return getAncestorOfType(isTSInterfaceBody, node) !== null;
}
function inConstructor(node) {
    const methodDefinition = getAncestorOfType(isMethodDefinition, node);
    return (methodDefinition !== null &&
        isIdentifier(methodDefinition.key) &&
        methodDefinition.key.name === "constructor");
}
function isInReturnType(node) {
    return (getAncestorOfType((n) => n.parent != undefined &&
        isFunctionLike(n.parent) &&
        n.parent.returnType === n, node) !== null);
}
function isPropertyAccess(node) {
    return (node.parent !== undefined &&
        isMemberExpression(node.parent) &&
        node.parent.property === node);
}
function isPropertyName(node) {
    return (node.parent !== undefined &&
        isProperty(node.parent) &&
        node.parent.key === node);
}
function isIIFE(node) {
    return (isFunctionExpressionLike(node) &&
        node.parent !== undefined &&
        isCallExpression(node.parent) &&
        node.parent.callee === node);
}

const allowLocalMutationOptionSchema = {
    type: "object",
    properties: {
        allowLocalMutation: {
            type: "boolean",
        },
    },
    additionalProperties: false,
};
const ignorePatternOptionSchema = {
    type: "object",
    properties: {
        ignorePattern: {
            type: ["string", "array"],
            items: {
                type: "string",
            },
        },
    },
    additionalProperties: false,
};
const ignoreAccessorPatternOptionSchema = {
    type: "object",
    properties: {
        ignoreAccessorPattern: {
            type: ["string", "array"],
            items: {
                type: "string",
            },
        },
    },
    additionalProperties: false,
};
const ignoreClassOptionSchema = {
    type: "object",
    properties: {
        ignoreClass: {
            oneOf: [
                {
                    type: "boolean",
                },
                {
                    type: "string",
                    enum: ["fieldsOnly"],
                },
            ],
        },
    },
    additionalProperties: false,
};
const ignoreInterfaceOptionSchema = {
    type: "object",
    properties: {
        ignoreInterface: {
            type: "boolean",
        },
    },
    additionalProperties: false,
};
function getNodeIdentifierText(node, context) {
    return node === undefined || node === null
        ? undefined
        : isIdentifier(node)
            ? node.name
            : hasID(node)
                ? getNodeIdentifierText(node.id, context)
                : hasKey(node)
                    ? getNodeIdentifierText(node.key, context)
                    : isAssignmentExpression(node)
                        ? getNodeIdentifierText(node.left, context)
                        : isMemberExpression(node)
                            ? `${getNodeIdentifierText(node.object, context)}.${getNodeIdentifierText(node.property, context)}`
                            : isThisExpression(node)
                                ? "this"
                                : isUnaryExpression(node)
                                    ? getNodeIdentifierText(node.argument, context)
                                    : isExpressionStatement(node)
                                        ? context.getSourceCode().getText(node)
                                        : isTSArrayType(node) ||
                                            isTSIndexSignature(node) ||
                                            isTSTupleType(node) ||
                                            isTSTypeAnnotation(node) ||
                                            isTSTypeLiteral(node) ||
                                            isTSTypeReference(node)
                                            ? getNodeIdentifierText(node.parent, context)
                                            : undefined;
}
function getNodeIdentifierTexts(node, context) {
    return (isVariableDeclaration(node)
        ? node.declarations.flatMap((declarator) => getNodeIdentifierText(declarator, context))
        : [getNodeIdentifierText(node, context)]).filter((text) => text !== undefined);
}
function shouldIgnoreViaPattern(text, ignorePattern) {
    const patterns = Array.isArray(ignorePattern)
        ? ignorePattern
        : [ignorePattern];
    return patterns.some((pattern) => new RegExp(pattern).test(text));
}
function accessorPatternMatch([pattern, ...remainingPatternParts], textParts, allowExtra = false) {
    return pattern === undefined
        ? allowExtra || textParts.length === 0
        :
            pattern === "**"
                ? textParts.length === 0
                    ? accessorPatternMatch(remainingPatternParts, [], allowExtra)
                    : Array.from({ length: textParts.length })
                        .map((_element, index) => index)
                        .some((offset) => accessorPatternMatch(remainingPatternParts, textParts.slice(offset), true))
                :
                    pattern === "*"
                        ? textParts.length > 0 &&
                            accessorPatternMatch(remainingPatternParts, textParts.slice(1), allowExtra)
                        :
                            new RegExp(`^${escapeRegExp__default['default'](pattern).replace(/\\\*/g, ".*")}$`).test(textParts[0]) &&
                                accessorPatternMatch(remainingPatternParts, textParts.slice(1), allowExtra);
}
function shouldIgnoreViaAccessorPattern(text, ignorePattern) {
    const patterns = Array.isArray(ignorePattern)
        ? ignorePattern
        : [ignorePattern];
    return patterns.some((pattern) => accessorPatternMatch(pattern.split("."), text.split(".")));
}
function shouldIgnore(node, context, options) {
    return ((options.allowLocalMutation === true && inFunctionBody(node)) ||
        (options.ignoreClass === true && inClass(node)) ||
        (options.ignoreClass === "fieldsOnly" &&
            (isClassProperty(node) ||
                (isAssignmentExpression(node) &&
                    inClass(node) &&
                    isMemberExpression(node.left) &&
                    isThisExpression(node.left.object)))) ||
        (options.ignoreInterface === true && inInterface(node)) ||
        ((texts) => texts.length > 0
            ?
                (options.ignorePattern !== undefined &&
                    texts.every((text) => shouldIgnoreViaPattern(text, options.ignorePattern))) ||
                    (options.ignoreAccessorPattern !== undefined &&
                        texts.every((text) => shouldIgnoreViaAccessorPattern(text, options.ignoreAccessorPattern)))
            : false)(getNodeIdentifierTexts(node, context)));
}

const version = "3.7.1";

function checkNode(check, context, options) {
    return (node) => {
        if (!options || !shouldIgnore(node, context, options)) {
            const result = check(node, context, options);
            result.descriptors.forEach((descriptor) => result.context.report(descriptor));
        }
    };
}
function createRule(name, meta, defaultOptions, ruleFunctionsMap) {
    return experimentalUtils.ESLintUtils.RuleCreator((name) => `https://github.com/jonaskello/eslint-plugin-functional/blob/v${version}/docs/rules/${name}.md`)({
        name,
        meta,
        defaultOptions: [defaultOptions],
        create: (context, [options]) => Object.fromEntries(Object.entries(ruleFunctionsMap).map(([nodeSelector, ruleFunction]) => [
            nodeSelector,
            checkNode(ruleFunction, context, options),
        ])),
    });
}
function getTypeOfNode(node, context) {
    const { parserServices } = context;
    if (parserServices === undefined ||
        parserServices.program === undefined ||
        parserServices.esTreeNodeToTSNodeMap === undefined) {
        return null;
    }
    else {
        const checker = parserServices.program.getTypeChecker();
        const nodeType = checker.getTypeAtLocation(parserServices.esTreeNodeToTSNodeMap.get(node));
        const constrained = checker.getBaseConstraintOfType(nodeType);
        return constrained !== null && constrained !== void 0 ? constrained : nodeType;
    }
}
function getESTreeNode(node, context) {
    const { parserServices } = context;
    return parserServices === undefined ||
        parserServices.program === undefined ||
        parserServices.tsNodeToESTreeNodeMap === undefined
        ? null
        : parserServices.tsNodeToESTreeNodeMap.get(node);
}

const name$g = "functional-parameters";
const schema$g = [
    deepMerge.all([
        ignorePatternOptionSchema,
        {
            type: "object",
            properties: {
                allowRestParameter: {
                    type: "boolean",
                },
                allowArgumentsKeyword: {
                    type: "boolean",
                },
                enforceParameterCount: {
                    oneOf: [
                        {
                            type: "boolean",
                            enum: [false],
                        },
                        {
                            type: "string",
                            enum: ["atLeastOne", "exactlyOne"],
                        },
                        {
                            type: "object",
                            properties: {
                                count: {
                                    type: "string",
                                    enum: ["atLeastOne", "exactlyOne"],
                                },
                                ignoreIIFE: {
                                    type: "boolean",
                                },
                            },
                            additionalProperties: false,
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    ]),
];
const defaultOptions$g = {
    allowRestParameter: false,
    allowArgumentsKeyword: false,
    enforceParameterCount: {
        count: "atLeastOne",
        ignoreIIFE: true,
    },
};
const errorMessages$g = {
    restParam: "Unexpected rest parameter. Use a regular parameter of type array instead.",
    arguments: "Unexpected use of `arguments`. Use regular function arguments instead.",
    paramCountAtLeastOne: "Functions must have at least one parameter.",
    paramCountExactlyOne: "Functions must have exactly one parameter.",
};
const meta$g = {
    type: "suggestion",
    docs: {
        description: "Enforce functional parameters.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$g,
    schema: schema$g,
};
function getRestParamViolations(allowRestParameter, node) {
    return !allowRestParameter &&
        node.params.length > 0 &&
        isRestElement(node.params[node.params.length - 1])
        ? [
            {
                node: node.params[node.params.length - 1],
                messageId: "restParam",
            },
        ]
        : [];
}
function getParamCountViolations(enforceParameterCount, node) {
    if (enforceParameterCount === false ||
        (node.params.length === 0 &&
            typeof enforceParameterCount === "object" &&
            enforceParameterCount.ignoreIIFE &&
            isIIFE(node))) {
        return [];
    }
    else if (node.params.length === 0 &&
        (enforceParameterCount === "atLeastOne" ||
            (typeof enforceParameterCount === "object" &&
                enforceParameterCount.count === "atLeastOne"))) {
        return [
            {
                node,
                messageId: "paramCountAtLeastOne",
            },
        ];
    }
    else if (node.params.length !== 1 &&
        (enforceParameterCount === "exactlyOne" ||
            (typeof enforceParameterCount === "object" &&
                enforceParameterCount.count === "exactlyOne"))) {
        return [
            {
                node,
                messageId: "paramCountExactlyOne",
            },
        ];
    }
    else {
        return [];
    }
}
function checkFunction$2(node, context, options) {
    return {
        context,
        descriptors: [
            ...getRestParamViolations(options.allowRestParameter, node),
            ...getParamCountViolations(options.enforceParameterCount, node),
        ],
    };
}
function checkIdentifier(node, context, options) {
    return {
        context,
        descriptors: !options.allowArgumentsKeyword &&
            node.name === "arguments" &&
            !isPropertyName(node) &&
            !isPropertyAccess(node)
            ? [
                {
                    node,
                    messageId: "arguments",
                },
            ]
            : [],
    };
}
const rule$g = createRule(name$g, meta$g, defaultOptions$g, {
    FunctionDeclaration: checkFunction$2,
    FunctionExpression: checkFunction$2,
    ArrowFunctionExpression: checkFunction$2,
    Identifier: checkIdentifier,
});

function isExpected(expected) {
    return (actual) => actual === expected;
}
function isDirectivePrologue(node) {
    return (node.expression.type === experimentalUtils.AST_NODE_TYPES.Literal &&
        typeof node.expression.value === "string" &&
        node.expression.value.startsWith("use "));
}

const name$f = "immutable-data";
const schema$f = [
    deepMerge.all([
        ignorePatternOptionSchema,
        ignoreAccessorPatternOptionSchema,
        ignoreClassOptionSchema,
        {
            type: "object",
            properties: {
                ignoreImmediateMutation: {
                    type: "boolean",
                },
                assumeTypes: {
                    oneOf: [
                        {
                            type: "boolean",
                        },
                        {
                            type: "object",
                            properties: {
                                forArrays: {
                                    type: "boolean",
                                },
                                forObjects: {
                                    type: "boolean",
                                },
                            },
                            additionalProperties: false,
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    ]),
];
const defaultOptions$f = {
    ignoreClass: false,
    ignoreImmediateMutation: true,
    assumeTypes: {
        forArrays: true,
        forObjects: true,
    },
};
const errorMessages$f = {
    generic: "Modifying an existing object/array is not allowed.",
    object: "Modifying properties of existing object not allowed.",
    array: "Modifying an array is not allowed.",
};
const meta$f = {
    type: "suggestion",
    docs: {
        description: "Enforce treating data as immutable.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$f,
    schema: schema$f,
};
const arrayMutatorMethods = [
    "copyWithin",
    "fill",
    "pop",
    "push",
    "reverse",
    "shift",
    "sort",
    "splice",
    "unshift",
];
const arrayNewObjectReturningMethods = [
    "concat",
    "slice",
    "filter",
    "map",
    "reduce",
    "reduceRight",
];
const arrayConstructorFunctions = ["from", "of"];
const objectConstructorMutatorFunctions = [
    "assign",
    "defineProperties",
    "defineProperty",
    "setPrototypeOf",
];
function checkAssignmentExpression(node, context) {
    return {
        context,
        descriptors: isMemberExpression(node.left) &&
            !inConstructor(node)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
function checkUnaryExpression(node, context) {
    return {
        context,
        descriptors: node.operator === "delete" && isMemberExpression(node.argument)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
function checkUpdateExpression(node, context, options) {
    return {
        context,
        descriptors: isMemberExpression(node.argument) &&
            !shouldIgnore(node.argument, context, options)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
function isInChainCallAndFollowsNew(node, context, assumeArrayTypes) {
    return (isArrayExpression(node.object) ||
        (isNewExpression(node.object) &&
            isArrayConstructorType(getTypeOfNode(node.object.callee, context), assumeArrayTypes, node.object.callee)) ||
        (isCallExpression(node.object) &&
            isMemberExpression(node.object.callee) &&
            isIdentifier(node.object.callee.property) &&
            ((arrayConstructorFunctions.some(isExpected(node.object.callee.property.name)) &&
                isArrayConstructorType(getTypeOfNode(node.object.callee.object, context), assumeArrayTypes, node.object.callee.object)) ||
                arrayNewObjectReturningMethods.some(isExpected(node.object.callee.property.name)))));
}
function checkCallExpression$1(node, context, options) {
    const assumeTypesForArrays = options.assumeTypes === true ||
        (options.assumeTypes !== false && options.assumeTypes.forArrays === true);
    const assumeTypesForObjects = options.assumeTypes === true ||
        (options.assumeTypes !== false && options.assumeTypes.forObjects === true);
    return {
        context,
        descriptors: isMemberExpression(node.callee) && isIdentifier(node.callee.property)
            ?
                !shouldIgnore(node.callee.object, context, options) &&
                    arrayMutatorMethods.some((m) => m ===
                        node.callee
                            .property.name) &&
                    (!options.ignoreImmediateMutation ||
                        !isInChainCallAndFollowsNew(node.callee, context, assumeTypesForArrays)) &&
                    isArrayType(getTypeOfNode(node.callee.object, context), assumeTypesForArrays, node.callee.object)
                    ? [{ node, messageId: "array" }]
                    :
                        objectConstructorMutatorFunctions.some((m) => m ===
                            node.callee
                                .property.name) &&
                            node.arguments.length >= 2 &&
                            (isIdentifier(node.arguments[0]) ||
                                isMemberExpression(node.arguments[0])) &&
                            !shouldIgnore(node.arguments[0], context, options) &&
                            isObjectConstructorType(getTypeOfNode(node.callee.object, context), assumeTypesForObjects, node.callee.object)
                            ? [{ node, messageId: "object" }]
                            : []
            : [],
    };
}
const rule$f = createRule(name$f, meta$f, defaultOptions$f, {
    AssignmentExpression: checkAssignmentExpression,
    UnaryExpression: checkUnaryExpression,
    UpdateExpression: checkUpdateExpression,
    CallExpression: checkCallExpression$1,
});

const name$e = "no-class";
const schema$e = [];
const defaultOptions$e = {};
const errorMessages$e = {
    generic: "Unexpected class, use functions not classes.",
};
const meta$e = {
    type: "suggestion",
    docs: {
        description: "Disallow classes.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$e,
    schema: schema$e,
};
function checkClass(node, context) {
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
const rule$e = createRule(name$e, meta$e, defaultOptions$e, { ClassDeclaration: checkClass, ClassExpression: checkClass });

var tsutils = (() => {
    try {
        return require("tsutils");
    }
    catch (error) {
        return undefined;
    }
})();

const name$d = "no-conditional-statement";
const schema$d = [
    {
        type: "object",
        properties: {
            allowReturningBranches: {
                oneOf: [
                    {
                        type: "boolean",
                    },
                    {
                        type: "string",
                        enum: ["ifExhaustive"],
                    },
                ],
            },
        },
        additionalProperties: false,
    },
];
const defaultOptions$d = { allowReturningBranches: false };
const errorMessages$d = {
    incompleteBranch: "Incomplete branch, every branch in a conditional statement must contain a return statement.",
    incompleteIf: "Incomplete if, it must have an else statement and every branch must contain a return statement.",
    incompleteSwitch: "Incomplete switch, it must be exhaustive or have an default case and every case must contain a return statement.",
    unexpectedIf: "Unexpected if, use a conditional expression (ternary operator) instead.",
    unexpectedSwitch: "Unexpected switch, use a conditional expression (ternary operator) instead.",
};
const meta$d = {
    type: "suggestion",
    docs: {
        description: "Disallow conditional statements.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$d,
    schema: schema$d,
};
function isIfReturningBranch(statement) {
    return (isIfStatement(statement) ||
        isReturnStatement(statement) ||
        isThrowStatement(statement) ||
        isBreakStatement(statement) ||
        isContinueStatement(statement));
}
function getIfBranchViolations(node, context) {
    const branches = [node.consequent, node.alternate];
    const violations = branches.filter((branch) => {
        if (branch === null || isIfReturningBranch(branch)) {
            return false;
        }
        if (isExpressionStatement(branch)) {
            const expressionStatementType = getTypeOfNode(branch.expression, context);
            if (expressionStatementType !== null &&
                isNeverType(expressionStatementType)) {
                return false;
            }
        }
        if (isBlockStatement(branch)) {
            if (branch.body.some(isIfReturningBranch)) {
                return false;
            }
            if (branch.body.some((statement) => {
                if (isExpressionStatement(statement)) {
                    const expressionStatementType = getTypeOfNode(statement.expression, context);
                    return (expressionStatementType !== null &&
                        isNeverType(expressionStatementType));
                }
                return false;
            })) {
                return false;
            }
        }
        return true;
    });
    return violations.flatMap((node) => [
        { node, messageId: "incompleteBranch" },
    ]);
}
function isSwitchReturningBranch(statement) {
    return (isSwitchStatement(statement) ||
        isReturnStatement(statement) ||
        isThrowStatement(statement));
}
function getSwitchViolations(node, context) {
    const violations = node.cases.filter((branch) => {
        if (branch.consequent.length === 0) {
            return false;
        }
        if (branch.consequent.some(isSwitchReturningBranch)) {
            return false;
        }
        if (branch.consequent.every(isBlockStatement)) {
            const lastBlock = branch.consequent[branch.consequent.length - 1];
            if (lastBlock.body.some(isSwitchReturningBranch)) {
                return false;
            }
            if (lastBlock.body.some((statement) => {
                if (isExpressionStatement(statement)) {
                    const expressionStatementType = getTypeOfNode(statement.expression, context);
                    return (expressionStatementType !== null &&
                        isNeverType(expressionStatementType));
                }
                return false;
            })) {
                return false;
            }
        }
        if (branch.consequent.some((statement) => {
            if (isExpressionStatement(statement)) {
                const expressionStatementType = getTypeOfNode(statement.expression, context);
                return (expressionStatementType !== null &&
                    isNeverType(expressionStatementType));
            }
            return false;
        })) {
            return false;
        }
        return true;
    });
    return violations.flatMap((node) => [
        { node, messageId: "incompleteBranch" },
    ]);
}
function isExhaustiveIfViolation(node) {
    return node.alternate === null;
}
function isExhaustiveTypeSwitchViolation(node, context) {
    if (tsutils === undefined) {
        return true;
    }
    else {
        const discriminantType = getTypeOfNode(node.discriminant, context);
        if (discriminantType === null || !discriminantType.isUnion()) {
            return true;
        }
        else {
            const unionTypes = tsutils.unionTypeParts(discriminantType);
            const caseTypes = node.cases.reduce((types, c) => new Set([...types, getTypeOfNode(c.test, context)]), new Set());
            return (unionTypes.filter((unionType) => !caseTypes.has(unionType)).length !== 0);
        }
    }
}
function isExhaustiveSwitchViolation(node, context) {
    return (node.cases.length === 0 ||
        node.cases.every((c) => c.test !== null)
        ? isExhaustiveTypeSwitchViolation(node, context)
        : false);
}
function checkIfStatement(node, context, options) {
    return {
        context,
        descriptors: options.allowReturningBranches
            ? options.allowReturningBranches === "ifExhaustive"
                ? isExhaustiveIfViolation(node)
                    ? [{ node, messageId: "incompleteIf" }]
                    : getIfBranchViolations(node, context)
                : getIfBranchViolations(node, context)
            : [{ node, messageId: "unexpectedIf" }],
    };
}
function checkSwitchStatement(node, context, options) {
    return {
        context,
        descriptors: options.allowReturningBranches
            ? options.allowReturningBranches === "ifExhaustive"
                ? isExhaustiveSwitchViolation(node, context)
                    ? [{ node, messageId: "incompleteSwitch" }]
                    : getSwitchViolations(node, context)
                : getSwitchViolations(node, context)
            : [{ node, messageId: "unexpectedSwitch" }],
    };
}
const rule$d = createRule(name$d, meta$d, defaultOptions$d, {
    IfStatement: checkIfStatement,
    SwitchStatement: checkSwitchStatement,
});

const name$c = "no-expression-statement";
const schema$c = [
    deepMerge.all([
        ignorePatternOptionSchema,
        {
            type: "object",
            properties: {
                ignoreVoid: {
                    type: "boolean",
                },
            },
            additionalProperties: false,
        },
    ]),
];
const defaultOptions$c = {
    ignoreVoid: false,
};
const errorMessages$c = {
    generic: "Using expressions to cause side-effects not allowed.",
};
const meta$c = {
    type: "suggestion",
    docs: {
        description: "Disallow expression statements.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$c,
    schema: schema$c,
};
function checkExpressionStatement(node, context, options) {
    if (isDirectivePrologue(node)) {
        return {
            context,
            descriptors: [],
        };
    }
    if (options.ignoreVoid === true) {
        const type = getTypeOfNode(node.expression, context);
        return {
            context,
            descriptors: type !== null && isVoidType(type)
                ? []
                : [{ node, messageId: "generic" }],
        };
    }
    return {
        context,
        descriptors: [{ node, messageId: "generic" }],
    };
}
const rule$c = createRule(name$c, meta$c, defaultOptions$c, {
    ExpressionStatement: checkExpressionStatement,
});

const name$b = "no-let";
const schema$b = [
    deepMerge.all([allowLocalMutationOptionSchema, ignorePatternOptionSchema]),
];
const defaultOptions$b = {
    allowLocalMutation: false,
};
const errorMessages$b = {
    generic: "Unexpected let, use const instead.",
};
const meta$b = {
    type: "suggestion",
    docs: {
        description: "Disallow mutable variables.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$b,
    fixable: "code",
    schema: schema$b,
};
function checkVariableDeclaration(node, context) {
    return {
        context,
        descriptors: node.kind === "let" ? [{ node, messageId: "generic" }] : [],
    };
}
const rule$b = createRule(name$b, meta$b, defaultOptions$b, {
    VariableDeclaration: checkVariableDeclaration,
});

const name$a = "no-loop-statement";
const schema$a = [];
const defaultOptions$a = {};
const errorMessages$a = {
    generic: "Unexpected loop, use map or reduce instead.",
};
const meta$a = {
    type: "suggestion",
    docs: {
        description: "Disallow imperative loops.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$a,
    schema: schema$a,
};
function checkLoop(node, context) {
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
const rule$a = createRule(name$a, meta$a, defaultOptions$a, {
    ForStatement: checkLoop,
    ForInStatement: checkLoop,
    ForOfStatement: checkLoop,
    WhileStatement: checkLoop,
    DoWhileStatement: checkLoop,
});

const name$9 = "no-method-signature";
const schema$9 = [
    {
        type: "object",
        properties: {
            ignoreIfReadonly: {
                type: "boolean",
                default: true,
            },
        },
        additionalProperties: false,
    },
];
const defaultOptions$9 = {
    ignoreIfReadonly: true,
};
const errorMessages$9 = {
    generic: "Method signature is mutable, use property signature with readonly modifier instead.",
};
const meta$9 = {
    type: "suggestion",
    docs: {
        description: "Prefer property signatures with readonly modifiers over method signatures.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$9,
    schema: schema$9,
};
function checkTSMethodSignature(node, context, { ignoreIfReadonly }) {
    if (ignoreIfReadonly && inReadonly(node)) {
        return { context, descriptors: [] };
    }
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
const rule$9 = createRule(name$9, meta$9, defaultOptions$9, {
    TSMethodSignature: checkTSMethodSignature,
});

const name$8 = "no-mixed-type";
const schema$8 = [
    {
        type: "object",
        properties: {
            checkInterfaces: {
                type: "boolean",
            },
            checkTypeLiterals: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
const defaultOptions$8 = {
    checkInterfaces: true,
    checkTypeLiterals: true,
};
const errorMessages$8 = {
    generic: "Only the same kind of members allowed in types.",
};
const meta$8 = {
    type: "suggestion",
    docs: {
        description: "Restrict types so that only members of the same kind of are allowed in them.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$8,
    schema: schema$8,
};
function hasTypeElementViolations(typeElements) {
    const typeElementsTypeInfo = typeElements.map((member) => ({
        type: member.type,
        typeAnnotation: isTSPropertySignature(member) && member.typeAnnotation !== undefined
            ? member.typeAnnotation.typeAnnotation.type
            : undefined,
    }));
    return typeElementsTypeInfo.reduce((carry, member) => ({
        prevMemberType: member.type,
        prevMemberTypeAnnotation: member.typeAnnotation,
        violations: carry.prevMemberType !== undefined &&
            (carry.prevMemberType !== member.type ||
                (carry.prevMemberTypeAnnotation !== member.typeAnnotation &&
                    (carry.prevMemberTypeAnnotation === experimentalUtils.AST_NODE_TYPES.TSFunctionType ||
                        member.typeAnnotation === experimentalUtils.AST_NODE_TYPES.TSFunctionType))),
    }), {
        prevMemberType: undefined,
        prevMemberTypeAnnotation: undefined,
        violations: false,
    }).violations;
}
function checkTSInterfaceDeclaration(node, context, options) {
    return {
        context,
        descriptors: options.checkInterfaces && hasTypeElementViolations(node.body.body)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
function checkTSTypeAliasDeclaration(node, context, options) {
    return {
        context,
        descriptors: options.checkTypeLiterals &&
            isTSTypeLiteral(node.typeAnnotation) &&
            hasTypeElementViolations(node.typeAnnotation.members)
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
const rule$8 = createRule(name$8, meta$8, defaultOptions$8, {
    TSInterfaceDeclaration: checkTSInterfaceDeclaration,
    TSTypeAliasDeclaration: checkTSTypeAliasDeclaration,
});

const name$7 = "no-promise-reject";
const schema$7 = [];
const defaultOptions$7 = {};
const errorMessages$7 = {
    generic: "Unexpected reject, return an error instead.",
};
const meta$7 = {
    type: "suggestion",
    docs: {
        description: "Disallow try-catch[-finally] and try-finally patterns.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$7,
    schema: schema$7,
};
function checkCallExpression(node, context) {
    return {
        context,
        descriptors: isMemberExpression(node.callee) &&
            isIdentifier(node.callee.object) &&
            isIdentifier(node.callee.property) &&
            node.callee.object.name === "Promise" &&
            node.callee.property.name === "reject"
            ? [{ node, messageId: "generic" }]
            : [],
    };
}
const rule$7 = createRule(name$7, meta$7, defaultOptions$7, {
    CallExpression: checkCallExpression,
});

const name$6 = "no-return-void";
const schema$6 = [
    {
        type: "object",
        properties: {
            allowNull: {
                type: "boolean",
            },
            allowUndefined: {
                type: "boolean",
            },
            ignoreImplicit: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
const defaultOptions$6 = {
    allowNull: true,
    allowUndefined: true,
    ignoreImplicit: true,
};
const errorMessages$6 = {
    generic: "Function must return a value.",
};
const meta$6 = {
    type: "suggestion",
    docs: {
        description: "Disallow functions that don't return anything.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$6,
    schema: schema$6,
};
function checkFunction$1(node, context, options) {
    var _a, _b;
    if (node.returnType === undefined) {
        if (!options.ignoreImplicit && isFunctionLike(node)) {
            const functionType = getTypeOfNode(node, context);
            const returnType = (_b = (_a = functionType === null || functionType === void 0 ? void 0 : functionType.getCallSignatures()) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.getReturnType();
            if (returnType !== undefined &&
                (isVoidType(returnType) ||
                    (!options.allowNull && isNullType(returnType)) ||
                    (!options.allowUndefined && isUndefinedType(returnType)))) {
                return {
                    context,
                    descriptors: [{ node, messageId: "generic" }],
                };
            }
        }
    }
    else if (isTSVoidKeyword(node.returnType.typeAnnotation) ||
        (!options.allowNull && isTSNullKeyword(node.returnType.typeAnnotation)) ||
        (!options.allowUndefined &&
            isTSUndefinedKeyword(node.returnType.typeAnnotation))) {
        return {
            context,
            descriptors: [{ node: node.returnType, messageId: "generic" }],
        };
    }
    return {
        context,
        descriptors: [],
    };
}
const rule$6 = createRule(name$6, meta$6, defaultOptions$6, {
    FunctionDeclaration: checkFunction$1,
    FunctionExpression: checkFunction$1,
    ArrowFunctionExpression: checkFunction$1,
    TSFunctionType: checkFunction$1,
});

const name$5 = "no-this-expression";
const schema$5 = [];
const defaultOptions$5 = {};
const errorMessages$5 = {
    generic: "Unexpected this, use functions not classes.",
};
const meta$5 = {
    type: "suggestion",
    docs: {
        description: "Disallow this access.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$5,
    schema: schema$5,
};
function checkThisExpression(node, context) {
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
const rule$5 = createRule(name$5, meta$5, defaultOptions$5, {
    ThisExpression: checkThisExpression,
});

const name$4 = "no-throw-statement";
const schema$4 = [];
const defaultOptions$4 = {};
const errorMessages$4 = {
    generic: "Unexpected throw, throwing exceptions is not functional.",
};
const meta$4 = {
    type: "suggestion",
    docs: {
        description: "Disallow throwing exceptions.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$4,
    schema: schema$4,
};
function checkThrowStatement(node, context) {
    return { context, descriptors: [{ node, messageId: "generic" }] };
}
const rule$4 = createRule(name$4, meta$4, defaultOptions$4, {
    ThrowStatement: checkThrowStatement,
});

const name$3 = "no-try-statement";
const schema$3 = [
    {
        type: "object",
        properties: {
            allowCatch: {
                type: "boolean",
            },
            allowFinally: {
                type: "boolean",
            },
        },
        additionalProperties: false,
    },
];
const defaultOptions$3 = {
    allowCatch: false,
    allowFinally: false,
};
const errorMessages$3 = {
    catch: "Unexpected try-catch, this pattern is not functional.",
    finally: "Unexpected try-finally, this pattern is not functional.",
};
const meta$3 = {
    type: "suggestion",
    docs: {
        description: "Disallow try-catch[-finally] and try-finally patterns.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages$3,
    schema: schema$3,
};
function checkTryStatement(node, context, options) {
    return {
        context,
        descriptors: !options.allowCatch && node.handler !== null
            ? [{ node, messageId: "catch" }]
            : !options.allowFinally && node.finalizer !== null
                ? [{ node, messageId: "finally" }]
                : [],
    };
}
const rule$3 = createRule(name$3, meta$3, defaultOptions$3, {
    TryStatement: checkTryStatement,
});

const name$2 = "prefer-readonly-type";
const schema$2 = [
    deepMerge.all([
        allowLocalMutationOptionSchema,
        ignorePatternOptionSchema,
        ignoreClassOptionSchema,
        ignoreInterfaceOptionSchema,
        {
            type: "object",
            properties: {
                allowMutableReturnType: {
                    type: "boolean",
                },
                checkImplicit: {
                    type: "boolean",
                },
                ignoreCollections: {
                    type: "boolean",
                },
            },
            additionalProperties: false,
        },
    ]),
];
const defaultOptions$2 = {
    checkImplicit: false,
    ignoreClass: false,
    ignoreInterface: false,
    ignoreCollections: false,
    allowLocalMutation: false,
    allowMutableReturnType: false,
};
const errorMessages$2 = {
    array: "Only readonly arrays allowed.",
    implicit: "Implicitly a mutable array. Only readonly arrays allowed.",
    property: "A readonly modifier is required.",
    tuple: "Only readonly tuples allowed.",
    type: "Only readonly types allowed.",
};
const meta$2 = {
    type: "suggestion",
    docs: {
        description: "Prefer readonly array over mutable arrays.",
        category: "Best Practices",
        recommended: "error",
    },
    messages: errorMessages$2,
    fixable: "code",
    schema: schema$2,
};
const mutableToImmutableTypes = new Map([
    ["Array", "ReadonlyArray"],
    ["Map", "ReadonlyMap"],
    ["Set", "ReadonlySet"],
]);
const mutableTypeRegex = new RegExp(`^${Array.from(mutableToImmutableTypes.keys()).join("|")}$`);
function checkArrayOrTupleType(node, context, options) {
    if (options.ignoreCollections) {
        return {
            context,
            descriptors: [],
        };
    }
    else {
        return {
            context,
            descriptors: (!node.parent ||
                !isTSTypeOperator(node.parent) ||
                node.parent.operator !== "readonly") &&
                (!options.allowMutableReturnType || !isInReturnType(node))
                ? [
                    {
                        node,
                        messageId: isTSTupleType(node) ? "tuple" : "array",
                        fix: node.parent && isTSArrayType(node.parent)
                            ? (fixer) => [
                                fixer.insertTextBefore(node, "(readonly "),
                                fixer.insertTextAfter(node, ")"),
                            ]
                            : (fixer) => fixer.insertTextBefore(node, "readonly "),
                    },
                ]
                : [],
        };
    }
}
function checkMappedType(node, context) {
    return {
        context,
        descriptors: node.readonly
            ? []
            : [
                {
                    node,
                    messageId: "property",
                    fix: (fixer) => fixer.insertTextBeforeRange([node.range[0] + 1, node.range[1]], " readonly"),
                },
            ],
    };
}
function checkTypeReference(node, context, options) {
    if (isIdentifier(node.typeName)) {
        if (options.ignoreCollections &&
            node.typeName.name.match(mutableTypeRegex)) {
            return {
                context,
                descriptors: [],
            };
        }
        else {
            const immutableType = mutableToImmutableTypes.get(node.typeName.name);
            return {
                context,
                descriptors: immutableType &&
                    (!options.allowMutableReturnType || !isInReturnType(node))
                    ? [
                        {
                            node,
                            messageId: "type",
                            fix: (fixer) => fixer.replaceText(node.typeName, immutableType),
                        },
                    ]
                    : [],
            };
        }
    }
    else {
        return {
            context,
            descriptors: [],
        };
    }
}
function checkProperty(node, context, options) {
    return {
        context,
        descriptors: !node.readonly &&
            (!options.allowMutableReturnType || !isInReturnType(node))
            ? [
                {
                    node,
                    messageId: "property",
                    fix: isTSIndexSignature(node) || isTSPropertySignature(node)
                        ? (fixer) => fixer.insertTextBefore(node, "readonly ")
                        : isTSParameterProperty(node)
                            ? (fixer) => fixer.insertTextBefore(node.parameter, "readonly ")
                            : (fixer) => fixer.insertTextBefore(node.key, "readonly "),
                },
            ]
            : [],
    };
}
function checkImplicitType(node, context, options) {
    if (options.checkImplicit) {
        const declarators = isFunctionLike(node)
            ? node.params
                .map((param) => isAssignmentPattern(param)
                ? {
                    id: param.left,
                    init: param.right,
                    node: param,
                }
                : undefined)
                .filter((param) => param !== undefined)
            : node.declarations.map((declaration) => ({
                id: declaration.id,
                init: declaration.init,
                node: declaration,
            }));
        return {
            context,
            descriptors: declarators.flatMap((declarator) => isIdentifier(declarator.id) &&
                declarator.id.typeAnnotation === undefined &&
                declarator.init !== null &&
                isArrayType(getTypeOfNode(declarator.init, context)) &&
                !options.ignoreCollections
                ? [
                    {
                        node: declarator.node,
                        messageId: "implicit",
                        fix: (fixer) => fixer.insertTextAfter(declarator.id, ": readonly unknown[]"),
                    },
                ]
                : []),
        };
    }
    else {
        return {
            context,
            descriptors: [],
        };
    }
}
const rule$2 = createRule(name$2, meta$2, defaultOptions$2, {
    ArrowFunctionExpression: checkImplicitType,
    ClassProperty: checkProperty,
    FunctionDeclaration: checkImplicitType,
    FunctionExpression: checkImplicitType,
    TSArrayType: checkArrayOrTupleType,
    TSIndexSignature: checkProperty,
    TSParameterProperty: checkProperty,
    TSPropertySignature: checkProperty,
    TSTupleType: checkArrayOrTupleType,
    TSMappedType: checkMappedType,
    TSTypeReference: checkTypeReference,
    VariableDeclaration: checkImplicitType,
});

const name$1 = "prefer-tacit";
const schema$1 = [
    deepMerge.all([
        ignorePatternOptionSchema,
        {
            type: "object",
            properties: {
                ignoreImmediateMutation: {
                    type: "boolean",
                },
                assumeTypes: {
                    oneOf: [
                        {
                            type: "boolean",
                            enum: [false],
                        },
                        {
                            type: "object",
                            properties: {
                                allowFixer: {
                                    type: "boolean",
                                },
                            },
                            additionalProperties: false,
                        },
                    ],
                },
            },
            additionalProperties: false,
        },
    ]),
];
const defaultOptions$1 = {
    assumeTypes: false,
};
const errorMessages$1 = {
    generic: "Potentially unnecessary function wrapper.",
};
const meta$1 = {
    type: "suggestion",
    docs: {
        description: "Replaces `x => f(x)` with just `f`.",
        category: "Best Practices",
        recommended: "warn",
    },
    messages: errorMessages$1,
    fixable: "code",
    schema: schema$1,
};
function isCallerViolation(caller, calleeType, context) {
    var _a, _b;
    if (calleeType.symbol === undefined) {
        return false;
    }
    else {
        const tsDeclaration = (_a = calleeType.symbol.valueDeclaration) !== null && _a !== void 0 ? _a : (_b = calleeType.symbol.declarations) === null || _b === void 0 ? void 0 : _b[0];
        if (tsDeclaration === undefined) {
            return false;
        }
        else {
            const declaration = getESTreeNode(tsDeclaration, context);
            return ((declaration !== null &&
                declaration !== undefined &&
                (isFunctionLike(declaration) || isTSFunctionType(declaration)) &&
                declaration.params.length === caller.arguments.length) ||
                (tsDeclaration.parameters !== undefined &&
                    tsDeclaration.parameters
                        .slice(caller.arguments.length)
                        .every((param) => param.initializer !== undefined ||
                        param.questionToken !== undefined)));
        }
    }
}
function getCallDescriptors(node, context, options, caller) {
    if (isIdentifier(caller.callee) &&
        node.params.length === caller.arguments.length &&
        node.params.every((param, index) => {
            const callArg = caller.arguments[index];
            return (isIdentifier(callArg) &&
                isIdentifier(param) &&
                callArg.name === param.name);
        })) {
        const calleeType = getTypeOfNode(caller.callee, context);
        const assumingTypes = (calleeType === null || calleeType.symbol === undefined) &&
            options.assumeTypes !== false;
        if (assumingTypes ||
            (calleeType !== null && isCallerViolation(caller, calleeType, context))) {
            const calleeName = caller.callee.name;
            return [
                {
                    node: node,
                    messageId: "generic",
                    fix: (typeof options.assumeTypes !== "object" && assumingTypes) ||
                        (typeof options.assumeTypes === "object" &&
                            !options.assumeTypes.allowFixer)
                        ? undefined
                        : (fixer) => fixer.replaceText(node, calleeName),
                },
            ];
        }
        else {
            return [];
        }
    }
    else {
        return [];
    }
}
function getDirectCallDescriptors(node, context, options) {
    if (isCallExpression(node.body)) {
        return getCallDescriptors(node, context, options, node.body);
    }
    else {
        return [];
    }
}
function getNestedCallDescriptors(node, context, options) {
    if (isBlockStatement(node.body) &&
        node.body.body.length === 1 &&
        isReturnStatement(node.body.body[0]) &&
        node.body.body[0].argument !== null &&
        isCallExpression(node.body.body[0].argument)) {
        return getCallDescriptors(node, context, options, node.body.body[0].argument);
    }
    else {
        return [];
    }
}
function checkFunction(node, context, options) {
    return {
        context,
        descriptors: [
            ...getDirectCallDescriptors(node, context, options),
            ...getNestedCallDescriptors(node, context, options),
        ],
    };
}
const rule$1 = createRule(name$1, meta$1, defaultOptions$1, {
    FunctionDeclaration: checkFunction,
    FunctionExpression: checkFunction,
    ArrowFunctionExpression: checkFunction,
});

const name = "prefer-type-literal";
const schema = [ignorePatternOptionSchema];
const defaultOptions = {};
const errorMessages = {
    generic: "Unexpected interface, use a type literal instead.",
};
const meta = {
    deprecated: true,
    replacedBy: ["@typescript-eslint/consistent-type-definitions"],
    type: "suggestion",
    docs: {
        description: "Prefer Type Literals over Interfaces.",
        category: "Best Practices",
        recommended: false,
    },
    messages: errorMessages,
    fixable: "code",
    schema,
};
function checkInterface(node, context) {
    return {
        context,
        descriptors: [
            {
                node,
                messageId: "generic",
                fix: node.extends === undefined ||
                    node.extends.every((type) => isIdentifier(type.expression))
                    ? (fixer) => [
                        fixer.replaceTextRange([node.range[0], node.range[0] + "interface".length], "type"),
                        fixer.insertTextBefore(node.body, "= "),
                        ...(node.extends === undefined
                            ? []
                            : [
                                fixer.replaceTextRange([node.id.range[1], node.body.range[0]], " "),
                                ...node.extends.map((type) => fixer.insertTextBefore(node.body, `${type.expression.name} & `)),
                            ]),
                        fixer.insertTextAfter(node, ";"),
                    ]
                    : undefined,
            },
        ],
    };
}
const rule = createRule(name, meta, defaultOptions, {
    TSInterfaceDeclaration: checkInterface,
});

const rules = {
    [name$g]: rule$g,
    [name$f]: rule$f,
    [name$e]: rule$e,
    [name$d]: rule$d,
    [name$c]: rule$c,
    [name$b]: rule$b,
    [name$a]: rule$a,
    [name$9]: rule$9,
    [name$8]: rule$8,
    [name$7]: rule$7,
    [name$6]: rule$6,
    [name$5]: rule$5,
    [name$4]: rule$4,
    [name$3]: rule$3,
    [name$2]: rule$2,
    [name$1]: rule$1,
    [name]: rule,
};

const config = {
    rules,
    configs: {
        all: config$a,
        recommended: config$3,
        "external-recommended": config$8,
        lite: config$2,
        "no-mutations": config$7,
        "no-exceptions": config$6,
        "no-object-orientation": config$5,
        "no-statements": config$4,
        currying: config$9,
        stylitic: config$1,
        stylistic: config$1,
    },
};

module.exports = config;
